Welcome to go-centrifuge


An overview of architecture and evolution
Tags: golang, go-centrifuge, supply-chain-financing, fintech


_Brought_ _to_ _you_ by *go-centrifuge* contributors

https://www.centrifuge.io
https://developer.centrifuge.io


* Intro

*go-centrifuge* is the go implementation of the Centrifuge OS interacting with the peer to peer network and our Ethereum smart contracts.


* What is this presentation about?

- An overview of how *go-centrifuge* works
- It documents the current state of *go-centrifuge* architecture
- It helps in driving discussion where we want to _evolve_ the architecture
- An architecture checkpoint in git so that we can understand our progress through time


* What this presentation is NOT about?

- A deep dive into specific functionality(eg: precise-proofs or transactions) or tech in the Node (But it would provide pointers on how to find those details)
- Fully fledged documentation on how to run a Node.
.link https://developer.centrifuge.io visit developer documentation for that.

* Part 1 - Current State

* A High Level View

  +-----+----+--------------------------------+
  |     |    |     Storage (leveldb)          |
  |     |    |                                |
  |     |    +--------------------------------+
  |     |    |    Repository                  |
  |     |Log |                      +-------+ |
  |     |    +----------------------+ Model +-------+----+
  |     |    |      Service         |       | |     |    |
  |     |    |                      |       | |     |    |
  |Config    +----------------------+       +-+ TX  |ETH |
  |     |    |                      +-------+ |     |    |
  |     |    | Controller (Handler)           |     |    |
  |     |    +---------------+----------------------+----+
  |     |    |  API          |   P2P          |Queue     |
  |     |    |               |                |          |
  +-----+----+---------------+----------------+----------+
  |                       Node                           |
  |                                                      |
  +------------------------------------------------------+


* Wait but first about Errors :)

We have a few conventions around error handling,
- All errors should be checked and propagated up the call chain (no panic or fatal)
- Use constant error values
- Use *github.com/centrifuge/go-centrifuge/errors* package to create errors

* Bootstrappers

.code ../bootstrap/bootstrapper.go /Bootstrapper/,/^}/

- Bootstrappers are little helpers in each package that need runtime initialization
- If those packages contain for example a service that needs dependencies such as configs its passed here
- Key is the *context map[string]interface{}* which holds already instantiated objects in the node for consumption
.link https://en.wikipedia.org/wiki/Inversion_of_control This is basically a form of inversion of control

* Configuration

- We use
.link https://github.com/spf13/viper Viper configuration library
- Viper manages reading and writing of YAML based config files
- Most runtime configs are inherited from
.link https://github.com/centrifuge/go-centrifuge/blob/develop/build/configs/default_config.yaml
- Some of configurations are parameterized so that they are selected based on user provided configs eg: `networks`

* Config Init

- When the node starts following flow is executed




* Accounts

.code ../config/configstore/model.go /Account exposes/,/^}/

- An account hold information regarding a single centrifuge identity

* Node Init

-


* Queuing

* Transactions (Async)

- A transaction represents a single unit of work in centrifuge OS
  eg: 1. Creating a document
      2. Updating a document
      3. Minting an NFT
- A transaction must be considered a failure if any of the actions in it fails.

* TX Manager

.code ../transactions/manager.go /Manager/,/^}/

* Ethereum interactions


* P2P


* API

- API created based on,
.link github.com/grpc-ecosystem/grpc-gateway GRPC Gateway project
- All the API endpoints and their requests/responses are defined as GRPC services and protobuf messages
- Example,
.code ../protobufs/document/service.proto /DocumentService/,/CreateDocumentProofForVersionRequest/

* API docs
- API documentation is generated with
.link https://swagger.io Swagger Tool
- The docs are built on CI and uploaded to
.link https://app.swaggerhub.com/apis/centrifuge.io/cent-node centrifuge-api-docs

* Storage


* Documents

- Model

* Testworld

* Build

- TODO - Explain how the build process works

* Part 2 - Evolution (Under construction)

* Lets evolve the architecture

- Evolution is an optimisation process
- Constraints guide the evolution
  Eg: 1. Testworld constrains code not to use global variables
      2. Separating interface and implementations makes code more modular and extensible


* Constraints


* Models

- All documents are `Model`s
.code ../documents/model.go /Model/,/^}/

- Something about precise-proofs

- Service interfaces


* Transactions



* Stuff

evolutionary architecture

What is the goal of having this discussion
We need to make it simple for someone to understand code to maintain it

Talk about how evolution works, starting point is important to know where the algo converges.


Why follow same stupid pattern everywhere? Because consistency trumps stupidity when it comes to maintenance

Go conventions in managing cyclic deps, and naming


